#!/usr/bin/env bun
/**
 * Guest Bundle Build Script
 *
 * Compiles the Guest bundle (React shims + Reconciler + Runtime helpers).
 *
 * Required output:
 *  - A TypeScript export file (for Engine to import): src/guest/build/bundle.ts
 *
 * Optional outputs (use flags):
 *  - Merged TypeScript file (for debugging): src/guest/build/guest-bundle.merged.ts
 *  - IIFE JS bundle (for inspection/injection): src/guest/build/guest-bundle.js
 *  - Debug merged file (runtime + app): <app>/debug-merged.ts
 *
 * Usage:
 *   bun src/scripts/build-guest.ts
 *   bun src/scripts/build-guest.ts --debug          # Non-minified for debugging
 *   bun src/scripts/build-guest.ts --write-js       # Also write src/guest/build/guest-bundle.js
 *   bun src/scripts/build-guest.ts --write-merged   # Also write src/guest/build/guest-bundle.merged.ts
 *   bun src/scripts/build-guest.ts --merge-app <path>  # Merge with app source and typecheck
 *
 * Example (merge with counterapp):
 *   bun src/scripts/build-guest.ts --merge-app ../Canvas/Subsystem/askc-app-examples/counterapp
 */

import * as fs from 'fs';
import * as path from 'path';

const SCRIPTS_DIR = path.resolve(import.meta.dir);
const SRC_DIR = path.join(SCRIPTS_DIR, '..');
const GUEST_DIR = path.join(SRC_DIR, 'guest');
const INPUT = path.join(GUEST_DIR, 'guest-bundle.ts');
const OUTPUT_DIR = path.join(GUEST_DIR, 'build');
const OUTPUT_JS = path.join(OUTPUT_DIR, 'guest-bundle.js');
const OUTPUT_TS_MERGED = path.join(OUTPUT_DIR, 'guest-bundle.merged.ts');
const OUTPUT_BUNDLE_TS = path.join(OUTPUT_DIR, 'bundle.ts');
const TEMP_DIR = '/tmp/rill-guest-build';
const TEMP_FILE = path.join(TEMP_DIR, 'guest-bundle.js');

// Flags
const isDebug = process.argv.includes('--debug');
// Extra outputs are useful for debugging/inspection, but not required at runtime.
// Default off to avoid committing build artifacts.
const shouldWriteJSFile = process.argv.includes('--write-js');
const shouldWriteMergedTS = process.argv.includes('--write-merged');

// --merge-app <path> : Merge runtime with app source and typecheck
const mergeAppIndex = process.argv.indexOf('--merge-app');
const mergeAppPath = mergeAppIndex !== -1 ? process.argv[mergeAppIndex + 1] : null;

/**
 * Generate merged TypeScript for debugging
 * Concatenates all source files in dependency order
 */
async function generateMergedTS(): Promise<string> {
  const files = [
    'init.ts',
    'globals-setup.ts',
    'types.ts',
    'shims/react-core.ts',
    'shims/hooks.ts',
    'shims/context.ts',
    'shims/component.ts',
    'shims/react-native.ts',
    'shims/react.ts',
    'reconciler/types.ts',
    'reconciler/operation-collector.ts',
    'reconciler/guest-encoder.ts',
    'reconciler/element-transform.ts',
    'reconciler/host-config.ts',
    'reconciler/devtools.ts',
    'reconciler/reconciler-manager.ts',
    'reconciler/index.ts',
    'guest-bundle.ts',
  ];

  const header = `/**
 * Guest Bundle - Merged TypeScript Source
 *
 * AUTO-GENERATED - DO NOT EDIT
 * Run: bun src/scripts/build-guest.ts
 *
 * This file contains all Guest source code merged for debugging.
 * Use this to understand the Guest bundle structure and debug issues.
 *
 * Generated: ${new Date().toISOString()}
 */

`;

  let merged = header;

  for (const file of files) {
    const filePath = path.join(GUEST_DIR, file);
    if (fs.existsSync(filePath)) {
      const content = await Bun.file(filePath).text();
      merged += `\n// ============================================\n`;
      merged += `// FILE: ${file}\n`;
      merged += `// ============================================\n\n`;
      merged += content;
      merged += '\n';
    }
  }

  return merged;
}

/**
 * Find all TypeScript/TSX files in app directory
 */
async function findAppSourceFiles(appDir: string): Promise<string[]> {
  const srcDir = path.join(appDir, 'src');
  const files: string[] = [];

  async function scanDir(dir: string): Promise<void> {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        await scanDir(fullPath);
      } else if (entry.name.endsWith('.tsx') || entry.name.endsWith('.ts')) {
        files.push(fullPath);
      }
    }
  }

  if (fs.existsSync(srcDir)) {
    await scanDir(srcDir);
  }

  return files;
}

/**
 * Generate merged debug file: runtime + app source
 */
async function generateDebugMerged(
  runtimeMerged: string,
  appDir: string
): Promise<{ content: string; outputPath: string }> {
  const appName = path.basename(appDir);
  const appFiles = await findAppSourceFiles(appDir);
  // Use .tsx extension for JSX support
  const outputPath = path.join(appDir, 'debug-merged.tsx');

  let content = `/**
 * Debug Merged File - Guest Runtime + ${appName}
 *
 * AUTO-GENERATED by: bun src/scripts/build-guest.ts --merge-app ${appDir}
 * Generated: ${new Date().toISOString()}
 *
 * This file merges the Rill guest runtime with your app source for debugging.
 * You can:
 *   1. Run typecheck: bun tsc --noEmit debug-merged.tsx
 *   2. Set breakpoints in VSCode
 *   3. Step through both runtime and app code
 */

// ============================================
// JSX Type Declarations (for typecheck)
// ============================================

// Rill SDK exports string identifiers for components.
// These declarations make them valid JSX elements.
declare global {
  namespace JSX {
    interface IntrinsicElements {
      View: Record<string, unknown>;
      Text: Record<string, unknown>;
      ScrollView: Record<string, unknown>;
      TouchableOpacity: Record<string, unknown>;
      Image: Record<string, unknown>;
      Button: Record<string, unknown>;
      TextInput: Record<string, unknown>;
      FlatList: Record<string, unknown>;
      Switch: Record<string, unknown>;
      ActivityIndicator: Record<string, unknown>;
      PanelMarker: Record<string, unknown>;
    }
  }
}

// ============================================
// PART 1: Rill Guest Runtime
// ============================================

`;

  // Add runtime code (strip the header since we have our own)
  const runtimeLines = runtimeMerged.split('\n');
  const headerEndIndex = runtimeLines.findIndex((line) => line.startsWith('// ==='));
  let runtimeBody = runtimeLines.slice(headerEndIndex).join('\n');

  // Transform arrow function generics to avoid JSX parsing conflicts
  // <T> -> <T,> or <T extends unknown> makes TypeScript parse it as generic, not JSX
  runtimeBody = transformGenericsForTSX(runtimeBody);

  content += runtimeBody;

  content += `

// ============================================
// PART 2: App Source Files (${appName})
// ============================================

`;

  // Process app source files
  for (const filePath of appFiles) {
    const relativePath = path.relative(appDir, filePath);
    const fileContent = await Bun.file(filePath).text();

    // Transform imports to inline references
    const transformedContent = transformAppImports(fileContent);

    content += `\n// ----------------------------------------\n`;
    content += `// FILE: ${relativePath}\n`;
    content += `// ----------------------------------------\n\n`;
    content += transformedContent;
    content += '\n';
  }

  // Add debug helpers at the end
  content += `

// ============================================
// PART 3: Debug Helpers
// ============================================

/**
 * Debug helper: Log all registered callbacks
 */
export function debugCallbacks(): void {
  const g = globalThis as Record<string, unknown>;
  if (g.__callbacks) {
    const callbacks = g.__callbacks as Map<string, unknown>;
    console.log('[DEBUG] Registered callbacks:', Array.from(callbacks.keys()));
    console.log('[DEBUG] Total count:', callbacks.size);
  }
}

/**
 * Debug helper: Check runtime state
 */
export function debugRuntimeState(): void {
  const g = globalThis as Record<string, unknown>;
  console.log('[DEBUG] __rill_schedule_render:', typeof g.__rill_schedule_render);
  console.log('[DEBUG] __rillHooks:', g.__rillHooks ? 'available' : 'missing');
  console.log('[DEBUG] React:', g.React ? 'available' : 'missing');
}

/**
 * Debug helper: Manually invoke a callback
 */
export function debugInvokeCallback(fnId: string, args: unknown[] = []): unknown {
  const g = globalThis as Record<string, unknown>;
  const invoke = g.__invokeCallback as ((id: string, args: unknown[]) => unknown) | undefined;
  if (invoke) {
    return invoke(fnId, args);
  }
  console.warn('[DEBUG] __invokeCallback not found');
  return undefined;
}
`;

  return { content, outputPath };
}

/**
 * Generate a typecheck-only file with app code + type declarations
 * This file is designed to pass typecheck (unlike debug-merged which is for reading)
 */
async function generateTypecheckFile(appDir: string): Promise<string> {
  const appName = path.basename(appDir);
  const appFiles = await findAppSourceFiles(appDir);

  let content = `/**
 * Typecheck File - ${appName}
 *
 * AUTO-GENERATED by: bun src/scripts/build-guest.ts --merge-app ${appDir}
 * Generated: ${new Date().toISOString()}
 *
 * This file is for typecheck only. For debugging, use debug-merged.tsx
 */

// ============================================
// React Types (subset needed for typecheck)
// ============================================

declare const React: {
  useState<T>(initial: T | (() => T)): [T, (v: T | ((prev: T) => T)) => void];
  useEffect(effect: () => void | (() => void), deps?: unknown[]): void;
  useRef<T>(initial: T): { current: T };
  useMemo<T>(factory: () => T, deps: unknown[]): T;
  useCallback<T extends (...args: never[]) => unknown>(callback: T, deps: unknown[]): T;
  useContext<T>(context: { _currentValue: T }): T;
  createElement: (type: unknown, props: unknown, ...children: unknown[]) => unknown;
  Fragment: symbol;
};

declare const useState: typeof React.useState;
declare const useEffect: typeof React.useEffect;
declare const useRef: typeof React.useRef;
declare const useMemo: typeof React.useMemo;
declare const useCallback: typeof React.useCallback;
declare const useContext: typeof React.useContext;

// ============================================
// Rill SDK Types
// ============================================

declare const View: 'View';
declare const Text: 'Text';
declare const ScrollView: 'ScrollView';
declare const TouchableOpacity: 'TouchableOpacity';
declare const Image: 'Image';
declare const Button: 'Button';
declare const TextInput: 'TextInput';
declare const FlatList: 'FlatList';
declare const Switch: 'Switch';
declare const ActivityIndicator: 'ActivityIndicator';

// ============================================
// Panel Types (askit)
// ============================================

declare const Panel: {
  Left: (props: { children: unknown }) => unknown;
  Right: (props: { children: unknown }) => unknown;
};

// ============================================
// JSX Intrinsic Elements
// ============================================

declare global {
  namespace JSX {
    interface IntrinsicElements {
      View: Record<string, unknown>;
      Text: Record<string, unknown>;
      ScrollView: Record<string, unknown>;
      TouchableOpacity: Record<string, unknown>;
      Image: Record<string, unknown>;
      Button: Record<string, unknown>;
      TextInput: Record<string, unknown>;
      FlatList: Record<string, unknown>;
      Switch: Record<string, unknown>;
      ActivityIndicator: Record<string, unknown>;
    }
  }
}

// ============================================
// App Source Files
// ============================================

`;

  // Process app files - strip imports, keep the code
  for (const filePath of appFiles) {
    const relativePath = path.relative(appDir, filePath);
    const fileContent = await Bun.file(filePath).text();

    // Strip import statements
    const strippedContent = stripImports(fileContent);

    content += `\n// ----------------------------------------\n`;
    content += `// FILE: ${relativePath}\n`;
    content += `// ----------------------------------------\n\n`;
    content += strippedContent;
    content += '\n';
  }

  content += '\nexport {};\n';

  return content;
}

/**
 * Strip import statements from source code
 */
function stripImports(content: string): string {
  const lines = content.split('\n');
  const result: string[] = [];

  for (const line of lines) {
    // Skip import lines
    if (line.trim().startsWith('import ')) {
      continue;
    }
    // Skip export default lines that reference imports
    if (line.trim() === 'export default') {
      continue;
    }
    result.push(line);
  }

  return result.join('\n');
}

/**
 * Transform arrow function generics to avoid JSX parsing conflicts in .tsx
 *
 * In .tsx files, `<T>` is parsed as JSX element.
 * Adding trailing comma `<T,>` forces TypeScript to parse as generic.
 *
 * Transforms:
 *   = <T>(x: T) =>       →  = <T,>(x: T) =>
 *   = <T, U>(x: T) =>    →  = <T, U>(x: T) =>  (already has comma, no change)
 *   <T extends Foo>      →  no change (extends disambiguates)
 */
function transformGenericsForTSX(content: string): string {
  // Match arrow function generic declarations that need comma
  // Pattern: = <SingleTypeParam>( where SingleTypeParam has no comma or extends
  // Examples that need transform:
  //   = <T>(
  //   = <P>(
  //   : <T>(
  // Examples that don't need transform:
  //   = <T, U>(  (already has comma)
  //   = <T extends Foo>(  (extends disambiguates)

  return content.replace(
    /([=:]\s*)<([A-Z][A-Za-z0-9_]*)\s*>\s*\(/g,
    (match, prefix, typeParam) => {
      return `${prefix}<${typeParam},>(`
    }
  );
}

/**
 * Transform app imports to work in merged context
 * - Remove rill/let or rill/sdk imports (provided by runtime)
 * - Keep relative imports as comments (they're inlined)
 */
function transformAppImports(content: string): string {
  const lines = content.split('\n');
  const transformed: string[] = [];

  for (const line of lines) {
    // Skip rill imports (provided by merged runtime)
    if (line.match(/import .* from ['"]rill\/(let|sdk)['"]/)) {
      transformed.push(`// [merged] ${line}`);
      continue;
    }

    // Skip react imports (provided by merged runtime)
    if (line.match(/import .* from ['"]react['"]/)) {
      transformed.push(`// [merged] ${line}`);
      continue;
    }

    // Mark relative imports as inlined
    if (line.match(/import .* from ['"]\.\/.*['"]/)) {
      transformed.push(`// [inlined] ${line}`);
      continue;
    }

    transformed.push(line);
  }

  return transformed.join('\n');
}

/**
 * Create a debug project with symlinks to source files
 * Source files remain unchanged - just organized for debugging
 */
async function createDebugProject(appDir: string): Promise<string> {
  const appName = path.basename(appDir);
  const debugDir = path.join(appDir, '.debug');

  // Clean and create debug directory
  if (fs.existsSync(debugDir)) {
    fs.rmSync(debugDir, { recursive: true });
  }
  fs.mkdirSync(debugDir, { recursive: true });

  console.log(`Creating debug project in ${debugDir}...`);

  // Create symlinks to rill source directories
  const rillSrcDir = path.join(SCRIPTS_DIR, '..');
  const symlinks = [
    { name: 'guest', target: path.join(rillSrcDir, 'guest') },
    { name: 'sdk', target: path.join(rillSrcDir, 'sdk') },
    { name: 'shared', target: path.join(rillSrcDir, 'shared') },
    { name: 'sandbox', target: path.join(rillSrcDir, 'sandbox') },
    { name: 'style-types.ts', target: path.join(rillSrcDir, 'style-types.ts') },
  ];

  for (const { name, target } of symlinks) {
    const linkPath = path.join(debugDir, name);
    if (fs.existsSync(target)) {
      fs.symlinkSync(target, linkPath, 'dir');
      console.log(`   Linked: ${name}/ → ${path.relative(debugDir, target)}`);
    }
  }

  // Symlink app source
  const appSrcDir = path.join(appDir, 'src');
  if (fs.existsSync(appSrcDir)) {
    fs.symlinkSync(appSrcDir, path.join(debugDir, 'app'), 'dir');
    console.log(`   Linked: app/ → ${path.relative(debugDir, appSrcDir)}`);
  }

  // Generate tsconfig.json
  const tsconfig = {
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      lib: ['ES2022', 'DOM'],
      jsx: 'preserve',
      strict: false,
      esModuleInterop: true,
      allowSyntheticDefaultImports: true,
      skipLibCheck: true,
      moduleResolution: 'bundler',
      noEmit: true,
      typeRoots: ['.'],
      types: [],               // No auto types
      baseUrl: '.',
      paths: {
        'rill/let': ['./sdk/index.ts'],
        'rill/sdk': ['./sdk/index.ts'],
        'react': ['./react-shim.ts'],
        'react-reconciler': ['./react-reconciler-stub.ts'],
        'askit': ['./askit-stub.ts'],
      },
    },
    include: ['app/**/*.ts', 'app/**/*.tsx', 'sdk/**/*.ts', '*.ts', '*.d.ts'],
    exclude: ['**/build/**', '**/*.test.*', 'guest/**', 'sandbox/**', 'shared/**'],
  };
  fs.writeFileSync(
    path.join(debugDir, 'tsconfig.json'),
    JSON.stringify(tsconfig, null, 2)
  );
  console.log(`   Created: tsconfig.json`);

  // Generate react-shim.ts with React namespace
  const reactShim = `
// React shim for debug project
export * from './guest/shims/react';
import { React } from './guest/shims/react';
export default React;

// Re-export React namespace types
export type ReactElement = ReturnType<typeof React.createElement>;
export type ReactNode = ReactElement | string | number | boolean | null | undefined;

// React namespace for JSX
declare namespace React {
  type ReactElement = ReturnType<typeof import('./guest/shims/react').React.createElement>;
  type ReactNode = ReactElement | string | number | boolean | null | undefined;
  type FC<P = {}> = (props: P) => ReactElement | null;
}
`;
  fs.writeFileSync(path.join(debugDir, 'react-shim.ts'), reactShim);
  console.log(`   Created: react-shim.ts`);

  // Generate react-reconciler stub
  const reconcilerStub = `
// react-reconciler stub for debug project
export default function Reconciler(config: any): any {
  return {
    createContainer: () => ({}),
    updateContainer: () => {},
    getPublicRootInstance: () => null,
  };
}
`;
  fs.writeFileSync(path.join(debugDir, 'react-reconciler-stub.ts'), reconcilerStub);
  console.log(`   Created: react-reconciler-stub.ts`);

  // Generate global.d.ts with JSX namespace and Node globals
  const globalDts = `
// Global type declarations for debug project

// Node.js globals
declare function require(id: string): any;
declare const module: { exports: any };
declare const exports: any;
declare const __dirname: string;
declare const __filename: string;
declare const process: { env: Record<string, string | undefined> };

// JSX types for rill components
declare namespace JSX {
  interface IntrinsicElements {
    View: any;
    Text: any;
    ScrollView: any;
    TouchableOpacity: any;
    Image: any;
    Button: any;
    TextInput: any;
    FlatList: any;
    Switch: any;
    ActivityIndicator: any;
    [elemName: string]: any;
  }
  type Element = any;
  type ElementClass = any;
  interface ElementAttributesProperty { props: {}; }
  interface ElementChildrenAttribute { children: {}; }
}

// React namespace for type annotations
declare namespace React {
  type ReactElement = any;
  type ReactNode = any;
  type FC<P = {}> = (props: P) => ReactElement | null;
  type ComponentType<P = {}> = FC<P>;
}
`;
  fs.writeFileSync(path.join(debugDir, 'global.d.ts'), globalDts);
  console.log(`   Created: global.d.ts`);

  // Generate askit stub (Panel types)
  const askitStub = `
// Askit stub for debug project
export const Panel = {
  Left: ({ children }: { children: unknown }) => children,
  Right: ({ children }: { children: unknown }) => children,
};
`;
  fs.writeFileSync(path.join(debugDir, 'askit-stub.ts'), askitStub);
  console.log(`   Created: askit-stub.ts`);

  // Generate entry point that imports everything
  const appFiles = await findAppSourceFiles(appDir);
  const imports = appFiles
    .map((f) => {
      const rel = path.relative(appSrcDir, f).replace(/\.tsx?$/, '');
      return `import './app/${rel}';`;
    })
    .join('\n');

  const entryContent = `
// Debug Entry Point - ${appName}
// Generated: ${new Date().toISOString()}
//
// This file imports all sources for unified debugging.
// Open this project in VSCode and set breakpoints anywhere.

// Guest Runtime
import './guest/guest-bundle';

// App Sources
${imports}
`;
  fs.writeFileSync(path.join(debugDir, 'entry.ts'), entryContent);
  console.log(`   Created: entry.ts`);

  return debugDir;
}

/**
 * Run TypeScript typecheck on app files only
 */
async function runTypecheckOnProject(projectDir: string): Promise<boolean> {
  console.log(`\nRunning typecheck on app files...`);

  // Get app files
  const appDir = path.join(projectDir, 'app');
  const appFiles = await findAppSourceFiles(path.dirname(projectDir));

  // Check each app file individually with skipLibCheck
  const args = [
    'bun', 'tsc', '--noEmit',
    '--skipLibCheck',
    '--jsx', 'preserve',
    '--target', 'ES2022',
    '--module', 'ESNext',
    '--moduleResolution', 'bundler',
    '--esModuleInterop',
    '--allowSyntheticDefaultImports',
    '--strict', 'false',
    '--baseUrl', projectDir,
    '--paths', JSON.stringify({
      'rill/let': ['./sdk/index.ts'],
      'rill/sdk': ['./sdk/index.ts'],
      'react': ['./react-shim.ts'],
      'askit': ['./askit-stub.ts'],
    }),
    ...appFiles.map(f => path.join('app', path.relative(path.join(path.dirname(projectDir), 'src'), f))),
  ];

  const proc = Bun.spawn(args, {
    cwd: projectDir,
    stdout: 'pipe',
    stderr: 'pipe',
  });

  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;

  if (exitCode === 0) {
    console.log('   ✓ Typecheck passed!');
    return true;
  }

  const allOutput = (stdout + '\n' + stderr).trim();
  const lines = allOutput.split('\n');
  const appErrors = lines.filter((l) => l.includes('error TS') && l.includes('app/'));

  if (appErrors.length === 0) {
    // No app errors, only runtime errors - that's OK
    console.log('   ✓ App code typecheck passed! (ignoring runtime warnings)');
    return true;
  }

  console.error(`   ✗ ${appErrors.length} type error(s) in app code:`);
  console.log(appErrors.slice(0, 20).join('\n'));
  if (appErrors.length > 20) {
    console.log(`   ... and ${appErrors.length - 20} more`);
  }

  return false;
}

/**
 * Run TypeScript typecheck on the merged debug file
 */
async function runTypecheckOnMergedFile(filePath: string): Promise<boolean> {
  const dir = path.dirname(filePath);
  const fileName = path.basename(filePath);
  console.log(`\nRunning typecheck on ${fileName}...`);

  const args = [
    'bun',
    'tsc',
    '--noEmit',
    '--skipLibCheck',
    '--jsx',
    'react-jsx',
    '--jsxImportSource',
    'react',
    '--moduleResolution',
    'bundler',
    '--target',
    'ES2020',
    '--module',
    'ESNext',
    '--esModuleInterop',
    '--strict',
    filePath,
  ];

  const proc = Bun.spawn(args, {
    cwd: dir,
    stdout: 'pipe',
    stderr: 'pipe',
  });

  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;

  if (exitCode === 0) {
    console.log('   ✓ Typecheck passed!');
    return true;
  }

  // Show first 50 lines of errors
  const allOutput = (stdout + '\n' + stderr).trim();
  const lines = allOutput.split('\n');
  const errorCount = lines.filter((l) => l.includes('error TS')).length;

  console.error(`   ✗ Typecheck failed with ${errorCount} error(s):`);
  console.log(lines.slice(0, 50).join('\n'));
  if (lines.length > 50) {
    console.log(`   ... and ${lines.length - 50} more lines`);
  }

  return false;
}

async function build(): Promise<void> {
  console.log('Building Guest Bundle...');
  console.log(`  Input: ${INPUT}`);
  console.log(`  Output TS (export): ${OUTPUT_BUNDLE_TS}`);
  if (shouldWriteJSFile) console.log(`  Output JS: ${OUTPUT_JS}`);
  if (shouldWriteMergedTS) console.log(`  Output TS (merged): ${OUTPUT_TS_MERGED}`);
  console.log(`  Mode: ${isDebug ? 'debug' : 'production'}`);

  // Ensure output directories exist
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
  }

  // Step 1 (optional): Generate merged TypeScript for debugging
  if (shouldWriteMergedTS) {
    console.log('\n1. Generating merged TypeScript...');
    const mergedTS = await generateMergedTS();
    fs.writeFileSync(OUTPUT_TS_MERGED, mergedTS);
    console.log(`   Wrote: ${OUTPUT_TS_MERGED} (${(mergedTS.length / 1024).toFixed(2)} KB)`);
  }

  // Note: Type checking is done at project level via `bun run typecheck`
  // Bun's bundler will catch critical errors during build

  // Step 2: Build with Bun
  console.log(`\n${shouldWriteMergedTS ? 2 : 1}. Building JavaScript bundle...`);
  const result = await Bun.build({
    entrypoints: [INPUT],
    outdir: TEMP_DIR,
    target: 'browser',
    format: 'iife',
    minify: !isDebug,
    naming: 'guest-bundle.[ext]',
    external: [], // Bundle everything
  });

  if (!result.success) {
    console.error('Build failed:');
    for (const log of result.logs) {
      console.error(log);
    }
    process.exit(1);
  }

  // Read the built code
  const jsCode = await Bun.file(TEMP_FILE).text();
  const jsSizeKB = (jsCode.length / 1024).toFixed(2);
  console.log(`   Bundle size: ${jsSizeKB} KB (${jsCode.length} bytes)`);

  // Step 3 (optional): Write JavaScript bundle
  if (shouldWriteJSFile) {
    fs.writeFileSync(OUTPUT_JS, jsCode);
    console.log(`   Wrote: ${OUTPUT_JS}`);
  }

  // Step 3: Generate TypeScript export file
  console.log(`\n${shouldWriteMergedTS ? 3 : 2}. Generating TypeScript export...`);
  const tsExport = `/**
 * Guest Bundle Export (Auto-generated)
 *
 * DO NOT EDIT - Generated by src/scripts/build-guest.ts
 * Run: bun src/scripts/build-guest.ts
 *
 * This is the compiled Guest bundle that provides:
 * - React/JSX shims
 * - Console setup
 * - Runtime helpers (event communication)
 * - RillReconciler (render, unmount, etc.)
 *
 * Size: ${jsSizeKB} KB (${isDebug ? 'debug' : 'minified'})
 * Generated: ${new Date().toISOString()}
 */

/**
 * The compiled Guest bundle code.
 * Eval this once during Engine initialization.
 */
export const GUEST_BUNDLE_CODE = ${JSON.stringify(jsCode)};

/**
 * Size in bytes (for monitoring)
 */
export const GUEST_BUNDLE_SIZE = ${jsCode.length};

/**
 * Is debug build
 */
export const GUEST_BUNDLE_DEBUG = ${isDebug};
`;

  fs.writeFileSync(OUTPUT_BUNDLE_TS, tsExport);
  console.log(`   Wrote: ${OUTPUT_BUNDLE_TS}`);

  // Cleanup
  try {
    fs.unlinkSync(TEMP_FILE);
  } catch {
    // Ignore cleanup errors
  }

  console.log('\n✓ Build complete!');
  console.log(`\nOutputs:`);
  console.log(`  - ${OUTPUT_BUNDLE_TS} (export for Engine)`);
  if (shouldWriteMergedTS) console.log(`  - ${OUTPUT_TS_MERGED} (merged TS for debugging)`);
  if (shouldWriteJSFile) console.log(`  - ${OUTPUT_JS} (compiled JS bundle)`);

  // Handle --merge-app: generate debug merged file and typecheck
  if (mergeAppPath) {
    const appDir = path.resolve(mergeAppPath);
    if (!fs.existsSync(appDir)) {
      console.error(`\n✗ App directory not found: ${appDir}`);
      process.exit(1);
    }

    console.log(`\n--- Merging with app: ${path.basename(appDir)} ---`);

    // Get runtime merged content (generate if not already done)
    let runtimeMerged: string;
    if (shouldWriteMergedTS && fs.existsSync(OUTPUT_TS_MERGED)) {
      runtimeMerged = await Bun.file(OUTPUT_TS_MERGED).text();
    } else {
      console.log('\nGenerating runtime merged source...');
      runtimeMerged = await generateMergedTS();
    }

    // Create debug project with symlinks (source files unchanged)
    const debugProjectDir = await createDebugProject(appDir);

    // Run typecheck on the debug project
    const typecheckPassed = await runTypecheckOnProject(debugProjectDir);

    if (typecheckPassed) {
      console.log(`\n✓ Debug project ready: ${debugProjectDir}`);
      console.log(`  Open in VSCode, set breakpoints, debug!`);
    } else {
      console.log(`\n⚠ Debug project created but has type errors`);
      console.log(`  Project: ${debugProjectDir}`);
      process.exit(1);
    }
  }
}

// Run build
build().catch((err: unknown) => {
  console.error('Build failed:', err);
  process.exit(1);
});
