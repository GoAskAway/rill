#!/usr/bin/env bun
/**
 * Guest Bundle Build Script
 *
 * Compiles the Guest bundle (React shims + Reconciler + Runtime helpers).
 *
 * Required output:
 *  - A TypeScript export file (for Engine to import): src/guest/build/bundle.ts
 *
 * Optional outputs (use flags):
 *  - Merged TypeScript file (for debugging): src/guest/build/guest-bundle.merged.ts
 *  - IIFE JS bundle (for inspection/injection): src/guest/build/guest-bundle.js
 *  - Debug merged file (runtime + app): <app>/debug-merged.ts
 *
 * Usage:
 *   bun src/scripts/build-guest.ts
 *   bun src/scripts/build-guest.ts --debug          # Non-minified for debugging
 *   bun src/scripts/build-guest.ts --write-js       # Also write src/guest/build/guest-bundle.js
 *   bun src/scripts/build-guest.ts --write-merged   # Also write src/guest/build/guest-bundle.merged.ts
 *   bun src/scripts/build-guest.ts --merge-app <path>  # Merge with app source and typecheck
 *
 * Example (merge with counterapp):
 *   bun src/scripts/build-guest.ts --merge-app ../Canvas/Subsystem/askc-app-examples/counterapp
 */

import * as fs from 'fs';
import * as path from 'path';

const SCRIPTS_DIR = path.resolve(import.meta.dir);
const SRC_DIR = path.join(SCRIPTS_DIR, '..');
const GUEST_DIR = path.join(SRC_DIR, 'guest');
const INPUT = path.join(GUEST_DIR, 'guest-bundle.ts');
const OUTPUT_DIR = path.join(GUEST_DIR, 'build');
const OUTPUT_JS = path.join(OUTPUT_DIR, 'guest-bundle.js');
const OUTPUT_TS_MERGED = path.join(OUTPUT_DIR, 'guest-bundle.merged.ts');
const OUTPUT_BUNDLE_TS = path.join(OUTPUT_DIR, 'bundle.ts');
const TEMP_DIR = '/tmp/rill-guest-build';
const TEMP_FILE = path.join(TEMP_DIR, 'guest-bundle.js');

// Flags
const isDebug = process.argv.includes('--debug');
// Extra outputs are useful for debugging/inspection, but not required at runtime.
// Default off to avoid committing build artifacts.
const shouldWriteJSFile = process.argv.includes('--write-js');
const shouldWriteMergedTS = process.argv.includes('--write-merged');

// --merge-app <path> : Merge runtime with app source and typecheck
const mergeAppIndex = process.argv.indexOf('--merge-app');
const mergeAppPath = mergeAppIndex !== -1 ? process.argv[mergeAppIndex + 1] : null;

/**
 * Generate merged TypeScript for debugging
 * Concatenates all source files in dependency order
 */
async function generateMergedTS(): Promise<string> {
  const files = [
    'init.ts',
    'globals-setup.ts',
    'types.ts',
    'shims/react-core.ts',
    'shims/hooks.ts',
    'shims/context.ts',
    'shims/component.ts',
    'shims/react-native.ts',
    'shims/react.ts',
    'reconciler/types.ts',
    'reconciler/operation-collector.ts',
    'reconciler/guest-encoder.ts',
    'reconciler/element-transform.ts',
    'reconciler/host-config.ts',
    'reconciler/devtools.ts',
    'reconciler/reconciler-manager.ts',
    'reconciler/index.ts',
    'guest-bundle.ts',
  ];

  const header = `/**
 * Guest Bundle - Merged TypeScript Source
 *
 * AUTO-GENERATED - DO NOT EDIT
 * Run: bun src/scripts/build-guest.ts
 *
 * This file contains all Guest source code merged for debugging.
 * Use this to understand the Guest bundle structure and debug issues.
 *
 * Generated: ${new Date().toISOString()}
 */

`;

  let merged = header;

  for (const file of files) {
    const filePath = path.join(GUEST_DIR, file);
    if (fs.existsSync(filePath)) {
      const content = await Bun.file(filePath).text();
      merged += `\n// ============================================\n`;
      merged += `// FILE: ${file}\n`;
      merged += `// ============================================\n\n`;
      merged += content;
      merged += '\n';
    }
  }

  return merged;
}

/**
 * Find all TypeScript/TSX files in app directory
 */
async function findAppSourceFiles(appDir: string): Promise<string[]> {
  const srcDir = path.join(appDir, 'src');
  const files: string[] = [];

  async function scanDir(dir: string): Promise<void> {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        await scanDir(fullPath);
      } else if (entry.name.endsWith('.tsx') || entry.name.endsWith('.ts')) {
        files.push(fullPath);
      }
    }
  }

  if (fs.existsSync(srcDir)) {
    await scanDir(srcDir);
  }

  return files;
}

/**
 * Generate merged debug file: runtime + app source
 */
async function generateDebugMerged(
  runtimeMerged: string,
  appDir: string
): Promise<{ content: string; outputPath: string }> {
  const appName = path.basename(appDir);
  const appFiles = await findAppSourceFiles(appDir);
  // Use .tsx extension for JSX support
  const outputPath = path.join(appDir, 'debug-merged.tsx');

  let content = `/**
 * Debug Merged File - Guest Runtime + ${appName}
 *
 * AUTO-GENERATED by: bun src/scripts/build-guest.ts --merge-app ${appDir}
 * Generated: ${new Date().toISOString()}
 *
 * This file merges the Rill guest runtime with your app source for debugging.
 * You can:
 *   1. Run typecheck: bun tsc --noEmit debug-merged.ts
 *   2. Set breakpoints in VSCode
 *   3. Step through both runtime and app code
 */

// ============================================
// PART 1: Rill Guest Runtime
// ============================================

`;

  // Add runtime code (strip the header since we have our own)
  const runtimeLines = runtimeMerged.split('\n');
  const headerEndIndex = runtimeLines.findIndex((line) => line.startsWith('// ==='));
  const runtimeBody = runtimeLines.slice(headerEndIndex).join('\n');
  content += runtimeBody;

  content += `

// ============================================
// PART 2: App Source Files (${appName})
// ============================================

`;

  // Process app source files
  for (const filePath of appFiles) {
    const relativePath = path.relative(appDir, filePath);
    const fileContent = await Bun.file(filePath).text();

    // Transform imports to inline references
    const transformedContent = transformAppImports(fileContent);

    content += `\n// ----------------------------------------\n`;
    content += `// FILE: ${relativePath}\n`;
    content += `// ----------------------------------------\n\n`;
    content += transformedContent;
    content += '\n';
  }

  // Add debug helpers at the end
  content += `

// ============================================
// PART 3: Debug Helpers
// ============================================

/**
 * Debug helper: Log all registered callbacks
 */
export function debugCallbacks(): void {
  const g = globalThis as Record<string, unknown>;
  if (g.__callbacks) {
    const callbacks = g.__callbacks as Map<string, unknown>;
    console.log('[DEBUG] Registered callbacks:', Array.from(callbacks.keys()));
    console.log('[DEBUG] Total count:', callbacks.size);
  }
}

/**
 * Debug helper: Check runtime state
 */
export function debugRuntimeState(): void {
  const g = globalThis as Record<string, unknown>;
  console.log('[DEBUG] __rill_schedule_render:', typeof g.__rill_schedule_render);
  console.log('[DEBUG] __rillHooks:', g.__rillHooks ? 'available' : 'missing');
  console.log('[DEBUG] React:', g.React ? 'available' : 'missing');
}

/**
 * Debug helper: Manually invoke a callback
 */
export function debugInvokeCallback(fnId: string, args: unknown[] = []): unknown {
  const g = globalThis as Record<string, unknown>;
  const invoke = g.__invokeCallback as ((id: string, args: unknown[]) => unknown) | undefined;
  if (invoke) {
    return invoke(fnId, args);
  }
  console.warn('[DEBUG] __invokeCallback not found');
  return undefined;
}
`;

  return { content, outputPath };
}

/**
 * Transform app imports to work in merged context
 * - Remove rill/let or rill/sdk imports (provided by runtime)
 * - Keep relative imports as comments (they're inlined)
 */
function transformAppImports(content: string): string {
  const lines = content.split('\n');
  const transformed: string[] = [];

  for (const line of lines) {
    // Skip rill imports (provided by merged runtime)
    if (line.match(/import .* from ['"]rill\/(let|sdk)['"]/)) {
      transformed.push(`// [merged] ${line}`);
      continue;
    }

    // Skip react imports (provided by merged runtime)
    if (line.match(/import .* from ['"]react['"]/)) {
      transformed.push(`// [merged] ${line}`);
      continue;
    }

    // Mark relative imports as inlined
    if (line.match(/import .* from ['"]\.\/.*['"]/)) {
      transformed.push(`// [inlined] ${line}`);
      continue;
    }

    transformed.push(line);
  }

  return transformed.join('\n');
}

/**
 * Run TypeScript typecheck on app source files
 * (Not on merged file - runtime has generics that conflict with JSX in .tsx)
 */
async function runTypecheckOnAppSources(appDir: string): Promise<boolean> {
  const srcDir = path.join(appDir, 'src');
  console.log(`\nRunning typecheck on app sources...`);

  // Check if app has tsconfig.json
  const tsconfigPath = path.join(appDir, 'tsconfig.json');
  const hasTsconfig = fs.existsSync(tsconfigPath);

  let args: string[];
  if (hasTsconfig) {
    // Use project's tsconfig
    args = ['bun', 'tsc', '--noEmit', '-p', tsconfigPath];
  } else {
    // Use inline config for app sources
    const sourceFiles = await findAppSourceFiles(appDir);
    args = [
      'bun',
      'tsc',
      '--noEmit',
      '--skipLibCheck',
      '--jsx',
      'react-jsx',
      '--jsxImportSource',
      'react',
      '--moduleResolution',
      'bundler',
      '--target',
      'ES2020',
      '--module',
      'ESNext',
      '--esModuleInterop',
      ...sourceFiles,
    ];
  }

  const proc = Bun.spawn(args, {
    cwd: appDir,
    stdout: 'pipe',
    stderr: 'pipe',
  });

  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;

  if (exitCode === 0) {
    console.log('   ✓ Typecheck passed!');
    return true;
  }

  console.error('   ✗ Typecheck failed:');
  if (stdout) console.log(stdout);
  if (stderr) console.error(stderr);
  return false;
}

async function build(): Promise<void> {
  console.log('Building Guest Bundle...');
  console.log(`  Input: ${INPUT}`);
  console.log(`  Output TS (export): ${OUTPUT_BUNDLE_TS}`);
  if (shouldWriteJSFile) console.log(`  Output JS: ${OUTPUT_JS}`);
  if (shouldWriteMergedTS) console.log(`  Output TS (merged): ${OUTPUT_TS_MERGED}`);
  console.log(`  Mode: ${isDebug ? 'debug' : 'production'}`);

  // Ensure output directories exist
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
  }

  // Step 1 (optional): Generate merged TypeScript for debugging
  if (shouldWriteMergedTS) {
    console.log('\n1. Generating merged TypeScript...');
    const mergedTS = await generateMergedTS();
    fs.writeFileSync(OUTPUT_TS_MERGED, mergedTS);
    console.log(`   Wrote: ${OUTPUT_TS_MERGED} (${(mergedTS.length / 1024).toFixed(2)} KB)`);
  }

  // Note: Type checking is done at project level via `bun run typecheck`
  // Bun's bundler will catch critical errors during build

  // Step 2: Build with Bun
  console.log(`\n${shouldWriteMergedTS ? 2 : 1}. Building JavaScript bundle...`);
  const result = await Bun.build({
    entrypoints: [INPUT],
    outdir: TEMP_DIR,
    target: 'browser',
    format: 'iife',
    minify: !isDebug,
    naming: 'guest-bundle.[ext]',
    external: [], // Bundle everything
  });

  if (!result.success) {
    console.error('Build failed:');
    for (const log of result.logs) {
      console.error(log);
    }
    process.exit(1);
  }

  // Read the built code
  const jsCode = await Bun.file(TEMP_FILE).text();
  const jsSizeKB = (jsCode.length / 1024).toFixed(2);
  console.log(`   Bundle size: ${jsSizeKB} KB (${jsCode.length} bytes)`);

  // Step 3 (optional): Write JavaScript bundle
  if (shouldWriteJSFile) {
    fs.writeFileSync(OUTPUT_JS, jsCode);
    console.log(`   Wrote: ${OUTPUT_JS}`);
  }

  // Step 3: Generate TypeScript export file
  console.log(`\n${shouldWriteMergedTS ? 3 : 2}. Generating TypeScript export...`);
  const tsExport = `/**
 * Guest Bundle Export (Auto-generated)
 *
 * DO NOT EDIT - Generated by src/scripts/build-guest.ts
 * Run: bun src/scripts/build-guest.ts
 *
 * This is the compiled Guest bundle that provides:
 * - React/JSX shims
 * - Console setup
 * - Runtime helpers (event communication)
 * - RillReconciler (render, unmount, etc.)
 *
 * Size: ${jsSizeKB} KB (${isDebug ? 'debug' : 'minified'})
 * Generated: ${new Date().toISOString()}
 */

/**
 * The compiled Guest bundle code.
 * Eval this once during Engine initialization.
 */
export const GUEST_BUNDLE_CODE = ${JSON.stringify(jsCode)};

/**
 * Size in bytes (for monitoring)
 */
export const GUEST_BUNDLE_SIZE = ${jsCode.length};

/**
 * Is debug build
 */
export const GUEST_BUNDLE_DEBUG = ${isDebug};
`;

  fs.writeFileSync(OUTPUT_BUNDLE_TS, tsExport);
  console.log(`   Wrote: ${OUTPUT_BUNDLE_TS}`);

  // Cleanup
  try {
    fs.unlinkSync(TEMP_FILE);
  } catch {
    // Ignore cleanup errors
  }

  console.log('\n✓ Build complete!');
  console.log(`\nOutputs:`);
  console.log(`  - ${OUTPUT_BUNDLE_TS} (export for Engine)`);
  if (shouldWriteMergedTS) console.log(`  - ${OUTPUT_TS_MERGED} (merged TS for debugging)`);
  if (shouldWriteJSFile) console.log(`  - ${OUTPUT_JS} (compiled JS bundle)`);

  // Handle --merge-app: generate debug merged file and typecheck
  if (mergeAppPath) {
    const appDir = path.resolve(mergeAppPath);
    if (!fs.existsSync(appDir)) {
      console.error(`\n✗ App directory not found: ${appDir}`);
      process.exit(1);
    }

    console.log(`\n--- Merging with app: ${path.basename(appDir)} ---`);

    // Get runtime merged content (generate if not already done)
    let runtimeMerged: string;
    if (shouldWriteMergedTS && fs.existsSync(OUTPUT_TS_MERGED)) {
      runtimeMerged = await Bun.file(OUTPUT_TS_MERGED).text();
    } else {
      console.log('\nGenerating runtime merged source...');
      runtimeMerged = await generateMergedTS();
    }

    // Generate debug merged file
    console.log('Generating debug merged file...');
    const { content, outputPath } = await generateDebugMerged(runtimeMerged, appDir);
    fs.writeFileSync(outputPath, content);
    console.log(`   Wrote: ${outputPath} (${(content.length / 1024).toFixed(2)} KB)`);

    // Run typecheck on app sources (informational - don't fail build)
    // Note: rill/sdk exports string identifiers, not typed React components,
    // so JSX type errors are expected unless using @types/react-native
    const typecheckPassed = await runTypecheckOnAppSources(appDir);

    console.log(`\n✓ Debug merged file ready: ${outputPath}`);
    if (!typecheckPassed) {
      console.log(`\n   Note: Type errors found in app sources.`);
      console.log(`   This is often expected - rill/sdk exports string identifiers`);
      console.log(`   for React Native components, not typed component classes.`);
      console.log(`   For full type checking, add @types/react-native to your project.`);
    }
  }
}

// Run build
build().catch((err: unknown) => {
  console.error('Build failed:', err);
  process.exit(1);
});
