#!/usr/bin/env bun
/**
 * Sandbox Runtime Build Script
 *
 * Compiles the TypeScript sandbox runtime into:
 * 1. A minified IIFE JS bundle for eval() injection
 * 2. Type declarations for development
 *
 * Usage:
 *   bun src/sandbox-runtime/build.ts
 *   bun src/sandbox-runtime/build.ts --debug  # Export debug bundle
 */

import * as fs from 'fs';
import * as path from 'path';

const ROOT = path.resolve(import.meta.dir);
const INPUT = path.join(ROOT, 'index.ts');
const OUTPUT_DIR = path.join(ROOT, 'dist');
const OUTPUT_BUNDLE = path.join(OUTPUT_DIR, 'sandbox-runtime.js');
const OUTPUT_BUNDLE_TS = path.join(ROOT, '../runtime/engine/sandbox-runtime-bundle.ts');
const TEMP_DIR = '/tmp/rill-sandbox-build';
const TEMP_FILE = path.join(TEMP_DIR, 'sandbox-runtime.js');

// Check for debug flag
const isDebug = process.argv.includes('--debug');

async function build(): Promise<void> {
  console.log('Building Sandbox Runtime...');
  console.log(`  Input: ${INPUT}`);
  console.log(`  Output: ${OUTPUT_BUNDLE_TS}`);
  console.log(`  Mode: ${isDebug ? 'debug' : 'production'}`);

  // Ensure output directories exist
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
  }

  // Type check first
  console.log('\n1. Type checking...');
  const typeCheck = Bun.spawnSync(['npx', 'tsc', '--noEmit'], {
    cwd: ROOT,
    stdio: ['inherit', 'inherit', 'inherit'],
  });

  if (typeCheck.exitCode !== 0) {
    console.error('Type check failed!');
    process.exit(1);
  }
  console.log('   Type check passed.');

  // Build with Bun
  console.log('\n2. Building bundle...');
  const result = await Bun.build({
    entrypoints: [INPUT],
    outdir: TEMP_DIR,
    target: 'browser',
    format: 'iife',
    minify: !isDebug,
    naming: 'sandbox-runtime.[ext]',
    external: [], // Bundle everything
  });

  if (!result.success) {
    console.error('Build failed:');
    for (const log of result.logs) {
      console.error(log);
    }
    process.exit(1);
  }

  // Read the built code
  let code = await Bun.file(TEMP_FILE).text();

  const sizeKB = (code.length / 1024).toFixed(2);
  console.log(`   Bundle size: ${sizeKB} KB (${code.length} bytes)`);

  // Copy to dist directory
  fs.writeFileSync(OUTPUT_BUNDLE, code);
  console.log(`   Wrote: ${OUTPUT_BUNDLE}`);

  // Generate the TypeScript file with the embedded code
  console.log('\n3. Generating TypeScript bundle export...');
  const tsOutput = `/**
 * Sandbox Runtime Bundle (Auto-generated)
 *
 * DO NOT EDIT - Generated by src/sandbox-runtime/build.ts
 * Run: bun src/sandbox-runtime/build.ts
 *
 * This is the compiled sandbox runtime that provides:
 * - React shims (createElement, hooks, etc.)
 * - Console setup
 * - Runtime helpers (event communication)
 * - DevTools integration
 *
 * Size: ${sizeKB} KB (${isDebug ? 'debug' : 'minified'})
 */

export const SANDBOX_RUNTIME_CODE = ${JSON.stringify(code)};

/**
 * Size in bytes (for monitoring)
 */
export const SANDBOX_RUNTIME_SIZE = ${code.length};

/**
 * Is debug build
 */
export const SANDBOX_RUNTIME_DEBUG = ${isDebug};
`;

  fs.writeFileSync(OUTPUT_BUNDLE_TS, tsOutput);
  console.log(`   Wrote: ${OUTPUT_BUNDLE_TS}`);

  // Cleanup
  try {
    fs.unlinkSync(TEMP_FILE);
  } catch {
    // Ignore cleanup errors
  }

  console.log('\nâœ“ Build complete!');
}

// Run build
build().catch((err: unknown) => {
  console.error('Build failed:', err);
  process.exit(1);
});
