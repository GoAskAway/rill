/**
 * Rill CLI - Build
 *
 * esbuild-based plugin bundler
 */

import { build as esbuild, context, type BuildContext } from 'esbuild';
import path from 'path';
import fs from 'fs';

/**
 * Build options
 */
export interface BuildOptions {
  /**
   * Entry file path
   */
  entry: string;

  /**
   * Output file path
   * @default 'dist/bundle.js'
   */
  outfile: string;

  /**
   * Enable minification
   * @default true
   */
  minify: boolean;

  /**
   * Generate sourcemap
   * @default false
   */
  sourcemap: boolean;

  /**
   * Enable watch mode
   * @default false
   */
  watch: boolean;

  /**
   * Metadata output path
   */
  metafile?: string;
}

/**
 * Runtime injection code
 * Sets up necessary global environment before bundle execution
 */
const RUNTIME_INJECT = `
// Rill Runtime Inject
(function() {
  'use strict';

  // Callback registry
  var __callbacks = new Map();
  var __callbackId = 0;

  // Register callback
  globalThis.__registerCallback = function(fn) {
    var id = 'fn_' + (++__callbackId) + '_' + Date.now().toString(36);
    __callbacks.set(id, fn);
    return id;
  };

  // Invoke callback
  globalThis.__invokeCallback = function(fnId, args) {
    var fn = __callbacks.get(fnId);
    if (fn) {
      try {
        return fn.apply(null, args || []);
      } catch (e) {
        console.error('[rill] Callback error:', e);
      }
    } else {
      console.warn('[rill] Callback not found:', fnId);
    }
  };

  // Remove callback
  globalThis.__removeCallback = function(fnId) {
    __callbacks.delete(fnId);
  };

  // Host event listeners
  var __hostEventListeners = new Map();

  // Register host event listener
  globalThis.__useHostEvent = function(eventName, callback) {
    if (!hostEventListeners.has(eventName)) {
      __hostEventListeners.set(eventName, new Set());
    }
    __hostEventListeners.get(eventName).add(callback);
  };

  // Handle host event
  globalThis.__handleHostEvent = function(eventName, payload) {
    var listeners = __hostEventListeners.get(eventName);
    if (listeners) {
      listeners.forEach(function(listener) {
        try {
          listener(payload);
        } catch (e) {
          console.error('[rill] Host event listener error:', e);
        }
      });
    }
  };

  // Handle host message
  globalThis.__handleHostMessage = function(message) {
    switch (message.type) {
      case 'CALL_FUNCTION':
        __invokeCallback(message.fnId, message.args);
        break;
      case 'HOST_EVENT':
        __handleHostEvent(message.eventName, message.payload);
        break;
      case 'CONFIG_UPDATE':
        if (globalThis.__config) {
          Object.assign(globalThis.__config, message.config);
        }
        break;
      case 'DESTROY':
        __callbacks.clear();
        __hostEventListeners.clear();
        break;
    }
  };

  // Config storage
  globalThis.__config = globalThis.__getConfig ? globalThis.__getConfig() : {};

})();
`;

/**
 * Execute build
 */
export async function build(options: BuildOptions): Promise<void> {
  const {
    entry,
    outfile,
    minify,
    sourcemap,
    watch,
    metafile,
  } = options;

  // Validate entry file
  const entryPath = path.resolve(process.cwd(), entry);
  if (!fs.existsSync(entryPath)) {
    throw new Error(`Entry file not found: ${entryPath}`);
  }

  // Ensure output directory exists
  const outDir = path.dirname(path.resolve(process.cwd(), outfile));
  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true });
  }

  // Create runtime injection file
  const injectPath = path.join(outDir, '.rill-runtime-inject.js');
  fs.writeFileSync(injectPath, RUNTIME_INJECT);

  console.log(`Building ${entry}...`);

  const buildOptions = {
    entryPoints: [entryPath],
    bundle: true,
    outfile: path.resolve(process.cwd(), outfile),
    format: 'iife' as const,
    globalName: '__RillPlugin',
    minify,
    sourcemap,
    target: 'es2020',
    metafile: !!metafile,

    // External dependencies - not bundled
    external: ['react-native'],

    // Inject runtime
    inject: [injectPath],

    // Alias configuration
    alias: {
      'rill/sdk': path.resolve(__dirname, '../sdk'),
    },

    // Define global constants
    define: {
      'process.env.NODE_ENV': '"production"',
      __DEV__: 'false',
    },

    // JSX configuration
    jsx: 'automatic' as const,

    // Log level
    logLevel: 'info' as const,

    // Banner - add protocol identifier
    banner: {
      js: '/* Rill Plugin Bundle - Generated by rill-cli */\n',
    },

    // Footer
    footer: {
      js: '\n/* End of Rill Plugin Bundle */',
    },
  };

  if (watch) {
    // Watch mode
    console.log('Watching for changes...');

    const ctx: BuildContext = await context(buildOptions);
    await ctx.watch();

    // Handle exit signal
    process.on('SIGINT', async () => {
      console.log('\nStopping watch mode...');
      await ctx.dispose();
      // Clean up temporary file
      if (fs.existsSync(injectPath)) {
        fs.unlinkSync(injectPath);
      }
      process.exit(0);
    });
  } else {
    // Single build
    const result = await esbuild(buildOptions);

    // Clean up temporary file
    if (fs.existsSync(injectPath)) {
      fs.unlinkSync(injectPath);
    }

    // Output build info
    const stats = fs.statSync(path.resolve(process.cwd(), outfile));
    const sizeKB = (stats.size / 1024).toFixed(2);
    console.log(`✓ Built: ${outfile} (${sizeKB} KB)`);

    // Output metafile
    if (metafile && result.metafile) {
      fs.writeFileSync(
        path.resolve(process.cwd(), metafile),
        JSON.stringify(result.metafile, null, 2)
      );
      console.log(`✓ Metafile: ${metafile}`);
    }
  }
}

/**
 * Analyze bundle
 */
export async function analyze(bundlePath: string): Promise<void> {
  const fullPath = path.resolve(process.cwd(), bundlePath);
  if (!fs.existsSync(fullPath)) {
    throw new Error(`Bundle not found: ${fullPath}`);
  }

  const content = fs.readFileSync(fullPath, 'utf-8');
  const stats = fs.statSync(fullPath);

  console.log('Bundle Analysis:');
  console.log(`  File: ${bundlePath}`);
  console.log(`  Size: ${(stats.size / 1024).toFixed(2)} KB`);
  console.log(`  Lines: ${content.split('\n').length}`);

  // Check for common issues
  if (content.includes('react-native')) {
    console.warn('  ⚠ Warning: Bundle contains "react-native" references');
  }

  if (content.includes('__DEV__') && !content.includes('__DEV__:false')) {
    console.warn('  ⚠ Warning: Bundle may contain development code');
  }
}
